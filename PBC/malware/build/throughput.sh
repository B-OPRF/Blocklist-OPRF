#!/usr/bin/env bash
# Usage:
#   ./run_multi_pairs.sh <num_clients> <base_port>
#
# Example:
#   ./run_multi_pairs.sh 50 9000
#   → creates ports 9000..9049, each with: server & synchronized client

set -euo pipefail

if [[ $# -ne 2 ]]; then
  echo "Usage: $0 <num_clients> <base_port>"
  exit 1
fi

NUM=$1
BASE_PORT=$2
EXE="./malware"
LOGDIR="./logs"
mkdir -p "$LOGDIR"

echo "Launching $NUM server-client pairs starting at port $BASE_PORT..."
echo "Logs → $LOGDIR/"

server_pids=()
client_pids=()

# Start all servers
for (( i=0; i<NUM; i++ )); do
  port=$(( BASE_PORT + i ))
  server_log="$LOGDIR/server_${port}.log"

  echo "Starting server on port $port"
  "$EXE" 2 "$port" >"$server_log" 2>&1 &
  server_pids+=("$!")
done

# Wait a moment for servers to open ports
sleep 2

# Create a barrier so all clients start at same time
BARRIER="$(mktemp -u)"
mkfifo "$BARRIER"

echo "Starting $NUM clients (will synchronize on barrier)..."
for (( i=0; i<NUM; i++ )); do
  port=$(( BASE_PORT + i ))
  client_log="$LOGDIR/client_${port}.log"

  (
    read -r _ < "$BARRIER"
    start=$(date +%s.%N)
    "$EXE" 1 "$port" >"$client_log" 2>&1
    end=$(date +%s.%N)
    latency=$(echo "$end - $start" | bc)
    echo "$latency" > "$LOGDIR/latency_${port}.txt"

  ) &
  client_pids+=("$!")
done

# Release all clients simultaneously
for (( i=0; i<NUM; i++ )); do
  echo "go" > "$BARRIER"
done
rm -f "$BARRIER"

echo "Clients started. Waiting for clients to finish..."

# Wait for all clients to complete
for pid in "${client_pids[@]}"; do
  wait "$pid"
done

echo "All clients finished. Shutting down servers..."

# Gracefully stop all servers
for pid in "${server_pids[@]}"; do
  kill "$pid" 2>/dev/null || true
  wait "$pid" 2>/dev/null || true
done

echo "Done. Logs are in: $LOGDIR/"

