#ifndef TLSH_H
#define TLSH_H
#include <emp-tool/emp-tool.h>
#include <iostream>
#include <fstream>
#include <vector>
#include "NTL/ZZ_pXFactoring.h"
#include "NTL/vec_ZZ_p.h"
#include "NTL/ZZ.h"
#include <cmath>
#include "util.h"


using namespace NTL;
using namespace std;
using namespace emp;


// const int BUCKETS = 256;
// const int DIGEST_SIZE = 128;
// const int BITLEN = 16;  

// static int v_table[256] = {
//   1, 87, 49, 12, 176, 178, 102, 166, 121, 193, 6, 84, 249, 230, 44, 163,
//   14, 197, 213, 181, 161, 85, 218, 80, 64, 239, 24, 226, 236, 142, 38, 200,
//   110, 177, 104, 103, 141, 253, 255, 50, 77, 101, 81, 18, 45, 96, 31, 222,
//   25, 107, 190, 70, 86, 237, 240, 34, 72, 242, 20, 214, 244, 227, 149, 235,
//   97, 234, 57, 22, 60, 250, 82, 175, 208, 5, 127, 199, 111, 62, 135, 248,
//   174, 169, 211, 58, 66, 154, 106, 195, 245, 171, 17, 187, 182, 179, 0, 243,
//   132, 56, 148, 75, 128, 133, 158, 100, 130, 126, 91, 13, 153, 246, 216, 219,
//   119, 68, 223, 78, 83, 88, 201, 99, 122, 11, 92, 32, 136, 114, 52, 10,
//   138, 30, 48, 183, 156, 35, 61, 26, 143, 74, 251, 94, 129, 162, 63, 152,
//   170, 7, 115, 167, 241, 206, 3, 150, 55, 59, 151, 220, 90, 53, 23, 131,
//   125, 173, 15, 238, 79, 95, 89, 16, 105, 137, 225, 224, 217, 160, 37, 123,
//   118, 73, 2, 157, 46, 116, 9, 145, 134, 228, 207, 212, 202, 215, 69, 229,
//   27, 188, 67, 124, 168, 252, 42, 4, 29, 108, 21, 247, 19, 205, 39, 203,
//   233, 40, 186, 147, 198, 192, 155, 33, 164, 191, 98, 204, 165, 180, 117, 76,
//   140, 36, 210, 172, 41, 54, 159, 8, 185, 232, 113, 196, 231, 47, 146, 120,
//   51, 65, 28, 144, 254, 221, 93, 189, 194, 139, 112, 43, 71, 109, 184, 209
// };

static Integer v_table_emp[256];

void init_v_table() {
    for (size_t i = 0; i < 256; ++i) {
        v_table_emp[i] = Integer(BITLEN, v_table[i], ALICE);
    }
}

// static int primes[6] = {2, 3, 5, 7, 11, 13};

// Direction constants
const bool ASCENDING = true;
const bool DESCENDING = false;

// Oblivious compare-and-swap
void compare_and_swap(Integer &a, Integer &b, bool dir) {
    Bit cond = (a > b);
    if (!dir) cond = !cond;
    Integer min_val = If(cond, b, a);
    Integer max_val = If(cond, a, b);
    a = min_val;
    b = max_val;
}

// Oblivious bitonic merge
void bitonic_merge(vector<Integer> arr, int low, int count, bool dir) {
    if (count <= 1) return;
    int k = count / 2;
    for (int i = low; i < low + k; ++i) {
        compare_and_swap(arr[i], arr[i + k], dir);
    }
    bitonic_merge(arr, low, k, dir);
    bitonic_merge(arr, low + k, k, dir);
}

// Bitonic sort (recursive)
void bitonic_sort(vector<Integer> arr, int low, int count, bool dir) {
    if (count <= 1) return;
    int k = count / 2;
    bitonic_sort(arr, low, k, ASCENDING);
    bitonic_sort(arr, low + k, k, DESCENDING);
    bitonic_merge(arr, low, count, dir);
}

// Sort wrapper (must be power of 2)
void oblivious_sort(vector<Integer> arr, int size) {
    if ((size & (size - 1)) != 0) {
        std::cerr << "Error: bitonic sort requires power-of-2 size." << std::endl;
        return;
    }
    bitonic_sort(arr, 0, size, ASCENDING);
}

Integer oblivious_read_v_table(const Integer& index, const Integer data[BUCKETS]) {
  Integer result(BITLEN, 0, ALICE);
  for (size_t i = 0; i < BUCKETS; ++i) {
      Bit is_selected = index == Integer(BITLEN, i, ALICE);
      result = If(is_selected, data[i], result);
  }
  return result;
}

void oblivious_write(vector<Integer> vec, const Integer& idx) {
  for (int i = 0; i < vec.size(); ++i) {
      Bit match = (idx == Integer(BITLEN, i, PUBLIC));
      vec[i] = If(match, vec[i]+Integer(BITLEN, 1, ALICE), vec[i]);
  }
}

Integer b_mapping(Integer salt, Integer i, Integer j, Integer k, Integer data[BUCKETS]) {
  Integer h = Integer(BITLEN, 0, ALICE);
  
  Integer h1 = oblivious_read_v_table(xor_integer(h, salt), data);
  Integer h2 = oblivious_read_v_table(xor_integer(h1, i), data);
  Integer h3 = oblivious_read_v_table(xor_integer(h2, j), data);
  Integer h4 = oblivious_read_v_table(xor_integer(h3, k), data);

  return h4;
}

vector<Integer> sliding_window_hash(vector<Integer> window, vector<Integer> histogram) {

  int counter = 0;
  for (size_t j=1; j<4; j++) {
    for (size_t k=j+1; k<5; k++) {
      Integer bi = b_mapping(Integer(BITLEN,primes[counter],ALICE), window[0], window[j], window[k], v_table_emp);
      oblivious_write(histogram, bi);
      counter += 1;
    }

  }

  return histogram;
}


vector<Integer> get_quartiles(vector<Integer> histogram) {
  vector<Integer> ret;

  // oblivious_sort(histogram, BUCKETS);
  Integer q1 = histogram[BUCKETS / 4];
  Integer q2 = histogram[BUCKETS / 2];
  Integer q3 = histogram[(3 * BUCKETS) / 4];
  ret.push_back(q1);
  ret.push_back(q2);
  ret.push_back(q3);

  return ret;
}

vector<Integer> digest_header(vector<Integer> ascii_encodings, vector<Integer> quartiles) {
  vector<Integer> ret;

  Integer second = Integer(BITLEN, std::log(ascii_encodings.size()), ALICE);
  ret.push_back(second);

  Integer q1_ratio = mod(quartiles[0]*Integer(BITLEN,100,ALICE)/quartiles[2], 16);
  Integer q2_ratio = mod(quartiles[1]*Integer(BITLEN,100,ALICE)/quartiles[2], 16);
  Integer third = (q1_ratio << 4) | q2_ratio;
  ret.push_back(third);

  return ret;
}

Integer digest_first(Integer ascii_encoding, Integer first) {
  first = first + mod(ascii_encoding, BUCKETS);

  return first;
}

vector<Integer> digest_body(vector<Integer> histogram, vector<Integer> quartiles) {
  vector<Integer> ret;
  for (int i=0; i<histogram.size(); i++) {
    Bit leq_q1 = (histogram[i] <= quartiles[0]);         // 00
    Bit leq_q2 = (histogram[i] <= quartiles[1]);         // 01
    Bit leq_q3 = (histogram[i] <= quartiles[2]);         // 10

    Bit is_q1 = leq_q1;
    Bit is_q2 = (!leq_q1) & leq_q2;
    Bit is_q3 = (!leq_q2) & leq_q3;
    Bit is_gt = !leq_q3;

    Integer enc00(2, 0, ALICE);  // 00
    Integer enc01(2, 1, ALICE);  // 01
    Integer enc10(2, 2, ALICE);  // 10
    Integer enc11(2, 3, ALICE);  // 11

    // Select output securely
    Integer out = enc00.select(is_q1,
                    enc01.select(is_q2,
                    enc10.select(is_q3,
                    enc11)));

    ret.push_back(out);
  }
  

  return ret;
}



#endif