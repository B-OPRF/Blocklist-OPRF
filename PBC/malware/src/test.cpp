#include <emp-tool/emp-tool.h>
#include <emp-ot/ot.h>
#include "TLSH.h"
#include "TLSH_plain.h"
#include <emp-sh2pc/emp-sh2pc.h>
#include "NTL/ZZ_pXFactoring.h"
#include "NTL/ZZ_p.h"
#include "NTL/vec_ZZ_p.h"
#include "NTL/ZZ.h"
#include<chrono>
#include "NTL/matrix.h"
#include "NTL/vec_vec_ZZ_p.h"
#include "NTL/BasicThreadPool.h"
#include "utils.h"
#include "constants.h"
#include "interpolate.h"
#include "OLESender.h"
#include "OLEReceiver.h"
#include "PSISender.h"
#include "PSIReceiver.h"
#include "AuthSender.h"
#include "AuthReceiver.h"
#include<vector>
#include<numeric>
#include<algorithm>
#include <thread>
#include<future>
#include<iostream>
#include <cstdlib>
#include<string>
#include <fstream>
#if defined(__linux__)
        #include <sys/time.h>
        #include <sys/resource.h>
#elif defined(__APPLE__)
        #include <unistd.h>
        #include <sys/resource.h>
        #include <mach/mach.h>
#endif


using namespace std;
using namespace emp;
using namespace chrono;
using namespace NTL;

#define TEST_Circuit 0
#define TEST_EC 1
#define TEST_SSDEEP 0
#define TEST_SDHASH 0
#define TEST_IC 0

int party, port;
NetIO * netio;

void setup() {
	// usleep(100);
	netio =  new emp::NetIO(party == emp::ALICE ? nullptr : "127.0.0.1", port, true);
	emp::setup_semi_honest(netio, party, 1024);
}

void done() {
	delete netio;
	finalize_semi_honest();
}


int main(int argc, char** argv) {
  std::ifstream lfile("../files/1.txt");
  if(!lfile) // test the file open.
  {
    std::cout<<"Error opening output file"<< std::endl;
    system("pause");
    return -1;
  }

  std::vector<int> ascii_encodings;
  char ch;
  while (lfile.get(ch)) {
    ascii_encodings.push_back(static_cast<unsigned char>(ch));  // ensure positive values
  }

  // std::cout << ascii_encodings.size() << "\n";

  if (TEST_Circuit) {

    setup_plain_prot(false, "");

    vector<Integer> file = intvec_to_emp(ascii_encodings);
    init_v_table();

    vector<Integer> histogram;

    for (size_t i=0; i<BUCKETS; i++) {
      histogram.push_back(Integer(BITLEN, 0, ALICE));
    }

    for (size_t i=5; i < file.size(); i++) {
      vector<Integer> window(file.begin()+(i-5), file.begin()+i);
      histogram = sliding_window_hash(window, histogram);
    }
    // vector<Integer> quartiles = get_quartiles(histogram);
    // vector<Integer> header = digest_header(file, quartiles);
    // vector<Integer> body = digest_body(histogram, quartiles);

    finalize_plain_prot();

    auto start_time = high_resolution_clock::now();
    setup_plain_prot(true, "header.txt");

    vector<Integer> quartiles = get_quartiles(histogram);
    vector<Integer> header = digest_header(file, quartiles);
    // vector<Integer> body = digest_body(histogram, quartiles);

    finalize_plain_prot();
    auto end_time = high_resolution_clock::now();
    auto duration = duration_cast<milliseconds>(end_time - start_time);
    std::cout << "Server Circuit Time: " << duration.count() << "ms" << endl; 
  }

  if (TEST_EC) {
    

    // parse_party_and_port(argv, &party, &port);
    
    // setup();

    // vector<Integer> file = intvec_to_emp(ascii_encodings);
    // init_v_table();

    // vector<Integer> histogram;

    // for (size_t i=0; i<BUCKETS; i++) {
    //   histogram.push_back(Integer(BITLEN, 0, ALICE));
    // }

    // for (size_t i=5; i < file.size(); i++) {
    //   vector<Integer> window(file.begin()+(i-5), file.begin()+i);
    //   histogram = sliding_window_hash(window, histogram);
    // }
    
    // done();

    // auto start_time = high_resolution_clock::now();
    // parse_party_and_port(argv, &party, &port);
    
    // setup();

    // vector<Integer> quartiles = get_quartiles(histogram);
    // vector<Integer> header = digest_header(file, quartiles);
    // if(party == ALICE) 
    // {
    //   std::cout << "Client EmbedMap OT Cost: " << netio->counter << "bytes" << endl;
    // }

    // if(party == BOB) 
    // {
    //   std::cout << "Server EmbedMap OT Cost: " << netio->counter << "bytes" << endl;
    // }

    // std::cout << "Number of AND gates used EmbedMap: "
    // << CircuitExecution::circ_exec->num_and() << std::endl;

    // done();
    // auto end_time = high_resolution_clock::now();
    // auto duration = duration_cast<milliseconds>(end_time - start_time);
    // if(party == ALICE)
    // {
    //   std::cout << "Client EmbedMap time: " << duration.count() << "ms" << endl; 
    // }
    // if(party == BOB)
    // {
    //   std::cout << "Server EmbedMap time: " << duration.count() << "ms" << endl; 
    // }

    ZZ_p::init(prime);
    //ZZ_p::init(ZZ(pow(2,57) - 1));
    ZZ_pContext context;
    context.save();

    vec_ZZ_p P; //= random_vec_ZZ_p(n+secParam);
    P.SetLength(n + secParam);
    for(int i = 0; i < n + secParam; i++)
    {
        P[i] = conv<ZZ_p>(ZZ(67*(2*i + 1)));
    }


    int setSize = 10000;
    int ESPVecLen = 16;

    vec_ZZ_p eval_points;
    eval_points.SetLength(2*ESPVecLen+1);
    for(int i = 0; i < eval_points.length(); i++)
    {
        eval_points[i] = conv<ZZ_p>(ZZ(57*(2*i + 1)));
    }

    // Defining the set of alphas
    vec_ZZ_p Alpha;
    Alpha.SetLength(k);
    int i = 0;
    for(i; i < k; i++)
    {
        Alpha[i] = P[i];
    } 

    // Defining the set of betas
    vec_ZZ_p Beta;
    Beta.SetLength(n);
    int j = 0;
    for(i,j; j < n; i++, j++)
    {
        Beta[j] = P[i];
    } 
    

    vec_ZZ_p servers_input;
    vec_ZZ_p clients_input_mul;
    vec_ZZ_p clients_input_add;
    int inputLength = setSize*ESPVecLen;       // Number of OLEs we will require
    servers_input.SetLength(inputLength);
    clients_input_mul.SetLength(inputLength);
    clients_input_add.SetLength(inputLength);


    for(int i = 0; i < inputLength; i++)
    {
        servers_input[i] = 1; //random_ZZ_p();            
        clients_input_mul[i] = i;
        clients_input_add[i] = i;
    }


    auto start_time = high_resolution_clock::now();
    parse_party_and_port(argv, &party, &port);
    //NetIO* ios[2];
    //for(int i = 0; i < 2; ++i) {ios[i] = new NetIO(party == ALICE?nullptr:"127.0.0.1",port+i);}         // We need two channels, one for communicating in the plain, the other for the OT
    
    int num_of_oles = inputLength;          // a number that is a multiple of 50
    int num_of_ole_instances;
    if(num_of_oles <= RSMaxLength)
        num_of_ole_instances = 1;
    else
        num_of_ole_instances = num_of_oles/RSMaxLength + 1;



    ZZ_pX embed_map_key_poly_one; //= random_ZZ_pX(ESPVecLen);
    ZZ_pX embed_map_key_poly_two;  //= random_ZZ_pX(2*ESPVecLen);
    vec_ZZ_p embed_map_key_poly_one_pts; 
    embed_map_key_poly_one_pts.SetLength(ESPVecLen + 1);
    vec_ZZ_p embed_map_key_poly_two_pts;
    embed_map_key_poly_two_pts.SetLength(2*ESPVecLen + 1);
    vec_ZZ_p set_of_X_for_key_poly_one;
    set_of_X_for_key_poly_one.SetLength(ESPVecLen + 1);
    vec_ZZ_p set_of_X_for_key_poly_two;
    set_of_X_for_key_poly_two.SetLength(2*ESPVecLen + 1);


    for(int i = 0; i < ESPVecLen + 1; i++)
    {
        embed_map_key_poly_one_pts[i] = 103*i + 5;
        set_of_X_for_key_poly_one[i] = eval_points[i];
    }
    embed_map_key_poly_one = interpolate(set_of_X_for_key_poly_one, embed_map_key_poly_one_pts);


        for(int i = 0; i < 2*ESPVecLen + 1; i++)
    {
        embed_map_key_poly_two_pts[i] = 83*i + 3;
        set_of_X_for_key_poly_two[i] = eval_points[i];
    }
    embed_map_key_poly_two = interpolate(set_of_X_for_key_poly_two, embed_map_key_poly_two_pts);


    if(party == ALICE)      // Receiver (Server)
    {
        vec_ZZ_p inSet[setSize];
        for(int i = 0; i < setSize; i++)
        {
            inSet[i].SetLength(ESPVecLen);
            for(int j = 0; j < ESPVecLen; j++)
            {
                inSet[i][j] = j+1; //random_ZZ_p();
            }
        }
      
        PSIReceiver psi_receiver = PSIReceiver(port, setSize, context, prime, ESPVecLen, Alpha, Beta);    
        //psi_receiver.get_intersection(eval_points, inSet);
        psi_receiver.test_and_commit(eval_points, inSet, embed_map_key_poly_one, embed_map_key_poly_two);

    }

    else                // Sender (Cient)
    {   
        vec_ZZ_p inSet[setSize];
        for(int i = 0; i < setSize; i++)
        {
            inSet[i].SetLength(ESPVecLen);
            for(int j = 0; j < ESPVecLen; j++)
            {
                inSet[i][j] = 2*j + 1; //random_ZZ_p();
            }
        }
        
        PSISender psi_sender = PSISender(port, setSize, context, prime, ESPVecLen, Alpha, Beta);    
        //psi_sender.get_intersection(eval_points, inSet);
        psi_sender.test_and_commit(eval_points, inSet, embed_map_key_poly_one, embed_map_key_poly_two);

        auto end_time = high_resolution_clock::now();
        auto duration = duration_cast<milliseconds>(end_time - start_time);
        std::cout << "Client TC response time: " << duration.count() << "ms" << endl;

    }
    


  }

  if (TEST_IC) {
    auto start_time = high_resolution_clock::now();

    auto start_local = high_resolution_clock::now();

    vector<int> z1 = TLSH_plain(ascii_encodings);
    string to_hash_str = "";
    for (int i=0; i<z1.size(); i++) {
      to_hash_str += to_string(z1[i]);
    }
    for (int i=0; i<ascii_encodings.size(); i++) {
      to_hash_str += to_string(ascii_encodings[i]);
    }
    string z2 = sha256_hex(to_hash_str);

    auto end_local = high_resolution_clock::now();
    auto duration_local = duration_cast<milliseconds>(end_local - start_local);
    std::cout << "Client ImplicitCheck local: " << duration_local.count() << "ms" << endl; 

    ZZ_p::init(prime);
    //ZZ_p::init(ZZ(pow(2,57) - 1));
    ZZ_pContext context;
    context.save();

    vec_ZZ_p P; //= random_vec_ZZ_p(n+secParam);
    P.SetLength(n + secParam);
    for(int i = 0; i < n + secParam; i++)
    {
        P[i] = conv<ZZ_p>(ZZ(67*(2*i + 1)));
    }


    int setSize = 1;
    int ESPVecLen = 32;

    vec_ZZ_p eval_points;
    eval_points.SetLength(2*ESPVecLen+1);
    for(int i = 0; i < eval_points.length(); i++)
    {
        eval_points[i] = conv<ZZ_p>(ZZ(57*(2*i + 1)));
    }

    // Defining the set of alphas
    vec_ZZ_p Alpha;
    Alpha.SetLength(k);
    int i = 0;
    for(i; i < k; i++)
    {
        Alpha[i] = P[i];
    } 

    // Defining the set of betas
    vec_ZZ_p Beta;
    Beta.SetLength(n);
    int j = 0;
    for(i,j; j < n; i++, j++)
    {
        Beta[j] = P[i];
    } 
    


    vec_ZZ_p servers_input;
    vec_ZZ_p clients_input_mul;
    vec_ZZ_p clients_input_add;
    int inputLength = 4*setSize*ESPVecLen;       // Number of OLEs we will require
    servers_input.SetLength(inputLength);
    clients_input_mul.SetLength(inputLength);
    clients_input_add.SetLength(inputLength);


    for(int i = 0; i < inputLength; i++)
    {
        servers_input[i] = 1; //random_ZZ_p();            
        clients_input_mul[i] = i;
        clients_input_add[i] = i;
    }



    parse_party_and_port(argv, &party, &port);
    //NetIO* ios[2];
    //for(int i = 0; i < 2; ++i) {ios[i] = new NetIO(party == ALICE?nullptr:"127.0.0.1",port+i);}         // We need two channels, one for communicating in the plain, the other for the OT
    
    int num_of_oles = inputLength;          // a number that is a multiple of 50
    int num_of_ole_instances;
    if(num_of_oles <= RSMaxLength)
        num_of_ole_instances = 1;
    else
        num_of_ole_instances = num_of_oles/RSMaxLength + 1;



    ZZ_pX embed_map_key_poly_one; //= random_ZZ_pX(ESPVecLen);
    ZZ_pX embed_map_key_poly_two;  //= random_ZZ_pX(2*ESPVecLen);
    vec_ZZ_p embed_map_key_poly_one_pts; 
    embed_map_key_poly_one_pts.SetLength(ESPVecLen + 1);
    vec_ZZ_p embed_map_key_poly_two_pts;
    embed_map_key_poly_two_pts.SetLength(2*ESPVecLen + 1);
    vec_ZZ_p set_of_X_for_key_poly_one;
    set_of_X_for_key_poly_one.SetLength(ESPVecLen + 1);
    vec_ZZ_p set_of_X_for_key_poly_two;
    set_of_X_for_key_poly_two.SetLength(2*ESPVecLen + 1);


    for(int i = 0; i < ESPVecLen + 1; i++)
    {
        embed_map_key_poly_one_pts[i] = 103*i + 5;
        set_of_X_for_key_poly_one[i] = eval_points[i];
    }
    embed_map_key_poly_one = interpolate(set_of_X_for_key_poly_one, embed_map_key_poly_one_pts);


        for(int i = 0; i < 2*ESPVecLen + 1; i++)
    {
        embed_map_key_poly_two_pts[i] = 83*i + 3;
        set_of_X_for_key_poly_two[i] = eval_points[i];
    }
    embed_map_key_poly_two = interpolate(set_of_X_for_key_poly_two, embed_map_key_poly_two_pts);


    if(party == ALICE)      // Receiver (Server)
    {
        vec_ZZ_p inSet[setSize];
        for(int i = 0; i < setSize; i++)
        {
            inSet[i].SetLength(ESPVecLen);
            for(int j = 0; j < ESPVecLen; j++)
            {
                inSet[i][j] = j+1; //random_ZZ_p();
            }
        }
        authenticateR(port, context, prime, num_of_ole_instances, Alpha, Beta, eval_points, inSet);    


    }

    else                // Sender (Cient)
    {   
        vec_ZZ_p inSet[setSize];
        for(int i = 0; i < setSize; i++)
        {
            inSet[i].SetLength(ESPVecLen);
            for(int j = 0; j < ESPVecLen; j++)
            {
                inSet[i][j] = 2*j+1; //random_ZZ_p();
            }
        }
        authenticateS(port, context, prime, num_of_ole_instances, Alpha, Beta, eval_points, inSet);

    }

    auto end_time = high_resolution_clock::now();
    auto duration = duration_cast<milliseconds>(end_time - start_time);
    if(party == ALICE)
    {
      std::cout << "Client ImplicitCheck latency: " << duration.count() << "ms" << endl; 
    }
    if(party == BOB)
    {
      std::cout << "Server ImplicitCheck latency: " << duration.count() << "ms" << endl; 
    }
  }

  


  return 0;
}