#ifndef SDHASH_H
#define SDHASH_H
#include <emp-tool/emp-tool.h>
#include <iostream>
#include <fstream>
#include <vector>
#include "NTL/ZZ_pXFactoring.h"
#include "NTL/vec_ZZ_p.h"
#include "NTL/ZZ.h"
#include <cmath>
#include "emp-sh2pc/emp-sh2pc.h"
#include "include/plain_circ_adj.h"
#include "include/plain_prot_adj.h"
#include "include/circuitStructs.h"
#include "include/examplePrograms.h"

using namespace NTL;
using namespace std;
using namespace emp;


const int BITLEN = 16;  

void oblivious_write_(vector<Integer> vec, const Integer& idx) {
  for (int i = 0; i < vec.size(); ++i) {
      Bit match = (idx == Integer(BITLEN, i, PUBLIC));
      vec[i] = If(match, vec[i]+Integer(BITLEN, 1, ALICE), vec[i]);
  }
}

// Shannon entropy (per-window) in bits/byte; normalized to [0,1000] by H/log2(l) with l=64
void normalized_entropy_0to1000(){
    int len = 64;
    vector<Integer> input;
    for (size_t i=0; i<len; i++) {
      input.push_back(Integer(BITLEN, 0, BOB));
    }
    vector<Integer> freq;
    for (size_t i=0; i<256; i++) {
      freq.push_back(Integer(BITLEN, 0, ALICE));
    }
    for (size_t i=0; i<len; i++) {
      oblivious_write_(freq, input[i]);
    }
    Integer H = Integer(BITLEN, 0, ALICE);
    for (size_t i=0; i<256; i++) {
      // H = If(freq[i] == Integer(BITLEN, 0, ALICE), H, H - (freq[i]/Integer(BITLEN, len, ALICE))*Integer(BITLEN, std::log2(freq[i]/Integer(BITLEN, len, ALICE)), ALICE));
      H = If(freq[i] == Integer(BITLEN, 0, ALICE), H, H - (freq[i]/Integer(BITLEN, len, ALICE)));
    }
    Integer norm = H / Integer(BITLEN, 6, ALICE);
    norm.reveal<int>();
}

// Direction constants
const bool ASCENDING = true;
const bool DESCENDING = false;

// Oblivious compare-and-swap
void compare_and_swap_(Integer &a, Integer &b, bool dir) {
    Bit cond = (a > b);
    if (!dir) cond = !cond;
    Integer min_val = If(cond, b, a);
    Integer max_val = If(cond, a, b);
    a = min_val;
    b = max_val;
}

// Oblivious bitonic merge
void bitonic_merge_(vector<Integer> arr, int low, int count, bool dir) {
    if (count <= 1) return;
    int k = count / 2;
    for (int i = low; i < low + k; ++i) {
        compare_and_swap_(arr[i], arr[i + k], dir);
    }
    bitonic_merge_(arr, low, k, dir);
    bitonic_merge_(arr, low + k, k, dir);
}

// Bitonic sort (recursive)
void bitonic_sort_(vector<Integer> arr, int low, int count, bool dir) {
    if (count <= 1) return;
    int k = count / 2;
    bitonic_sort_(arr, low, k, ASCENDING);
    bitonic_sort_(arr, low + k, k, DESCENDING);
    bitonic_merge_(arr, low, count, dir);
}

// Sort wrapper (must be power of 2)
void oblivious_sort_(vector<Integer> arr, int size) {
  if ((size & (size - 1)) != 0) {
      std::cerr << "Error: bitonic sort requires power-of-2 size." << std::endl;
      return;
  }
  bitonic_sort_(arr, 0, size, ASCENDING);
}


// Build digest from bytes
void leftmost(){
    int len = 64;
    vector<Integer> input;
    for (size_t i=0; i<len; i++) {
      input.push_back(Integer(BITLEN, 0, BOB));
    }
    
    oblivious_sort_(input, len);
    input[0].reveal<int>();
    
}

void sha3(){

  uint8_t input[64];
  uint8_t output_bytes[11];
  uint8_t output_bytes2[11];
  for (size_t i = 0; i < 7; ++i) {
    input[i] = i % 7;
  }
  emp::sha3_256(output_bytes, input, 64);

  emp::Integer integers[64];
  for (int64_t i = 0; i < 64; ++i) {
    integers[i] = Integer(8, i % 200, BOB);
  }

  emp::Integer output = Integer(10, 11, BOB);

  SHA3_256_Calculator sha3_256_calculator = SHA3_256_Calculator();
  sha3_256_calculator.sha3_256(&output, integers, 64);

}

void sdhash_digest(){
    int len = 64;
    vector<Integer> input;
    for (size_t i=0; i<len; i++) {
      input.push_back(Integer(BITLEN, 0, BOB));
    }
    sha3();
    
}


#endif