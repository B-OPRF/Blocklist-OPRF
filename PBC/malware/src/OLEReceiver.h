#ifndef OLESERVER_H
#define OLESERVER_H


#include <emp-tool/emp-tool.h>
#include "constants.h"
#include <emp-ot/ot.h>
#include <emp-sh2pc/emp-sh2pc.h>
#include "NTL/ZZ_pXFactoring.h"
#include "NTL/vec_ZZ_p.h"
#include "NTL/ZZ.h"
#include "utils.h"
#include<chrono>
#include "NTL/matrix.h"
#include "NTL/vec_vec_ZZ_p.h"
#include "NTL/BasicThreadPool.h"
#include<vector>
#include<numeric>
#include<algorithm>
#include <thread>
#include<future>
#include<iostream>
#include <cstdlib>
#include<string>
#include <fstream>
#if defined(__linux__)
        #include <sys/time.h>
        #include <sys/resource.h>
#elif defined(__APPLE__)
        #include <unistd.h>
        #include <sys/resource.h>
        #include <mach/mach.h>
#endif

using namespace std;
using std::vector;
using namespace chrono;
using namespace NTL;

#define DEBUG_COMM_V 0
#define DEBUG_COMM_W 0
#define DEBUG_OT 0
#define DEBUG_INTERPOLATE 0

class OLEReceiver
{

    public:
        int party = 1;
        int port;
        ZZ prime;
        int num_encoding_instances;
   
   
    OLEReceiver(int prt, ZZ_pContext context, ZZ prim, int num_oles)
    {
        context.restore();
        port = prt;
        prime = prim;
        num_encoding_instances = num_oles;
        cout << "Setup receiver with prime " << prime <<endl;
    }




    vec_ZZ_p encode_rs(vec_ZZ_p x, int inputLength, vec_ZZ_p Alpha, vec_ZZ_p Beta)
    {
        //int l = n - p;
        mat_ZZ_p G;
        mat_ZZ_p H;
        int L[l];


        // Defining the value of u
        vec_ZZ_p u = random_vec_ZZ_p(k);
        for(int i = 0; i < RSMaxLength; i++)
        {
            u[i] = x[i];
            if(u[i] == 0){
                cout << "ERROR in encoding" << endl;
                exit(0);
            }
        }    

        // Defining indices to add noise
        for(int i = 0; i < l; i++){
            L[i] = i;   // this is not a random selection!
        }


        
        // Defining the polynomial P    
        ZZ_pX polyP = interpolate(Alpha, u);
        //cout << "interpolation done" << endl;
        // Defining the Generator matrix
       
       /*
        G.SetDims(n, k);

        for(int i = 0; i < n; i++)
        {
            for(int j = 0; j < k; j++)
            {
                G[i][j] = (power(Beta[i],j) * coeff(polyP, j)) * inv(u[j]);
            }
        }
        */
        // sanity check
        /*
        for(int i = 0; i < n; i++)
        {
            if((G*u)[i] != eval(polyP, Beta[i]))
            {
            cout << "Error in computing G:" << (G*u)[i] << " " << eval(polyP, Beta[i]) << endl;
                break;
            }
        }
        */

        // generate v
        vec_ZZ_p v = random_vec_ZZ_p(n);
        for(int i = 0; i < l; ++i)
        {
            v[i] = eval(polyP, Beta[i]); //(G*u)[i]; // This is a hack for fast encoding generation
        }

        // Defining the polynomial Q   
        vec_ZZ_p V;
        V.SetLength(l);
    
    for(int i = 0; i < l; ++i)
        {
            V[i] = v[i];
        }
    
        vec_ZZ_p Beta_sub;
        Beta_sub.SetLength(l);

        for(int i = 0; i < l; ++i)
        {
            Beta_sub[i] = Beta[i];
        }
        ZZ_pX polyQ = interpolate(Beta_sub, V);

        //TODO: need to fix this for the correct set of random points
        /*
        //generate H
        H.SetDims(k, 2*k - 1);
        for(int i = 0; i < k; i++)
        {
            for(int j = 0; j < 2*(k)-1; j++)
            {
                H[i][j] = (power(Alpha[i],j) * coeff(polyQ, j))/V[l-1];
            }
        }
        */


        return v;
    }

    vec_ZZ_p ole_get_results(vec_ZZ_p blinded_interpolating_set, vec_ZZ_p Beta, vec_ZZ_p Alpha, int offset, int num_inputs)
    {

        vec_ZZ_p interpolating_points_Y;
        interpolating_points_Y.SetLength(l);
        vec_ZZ_p interpolating_points_X;
        interpolating_points_X.SetLength(l);
        
        for(int i = 0; i < l; i++)
        {
            interpolating_points_Y[i] = blinded_interpolating_set[i];
            interpolating_points_X[i] = Beta[i];
        }
        
        
        ZZ_pX polyRes = interpolate(interpolating_points_X, interpolating_points_Y);
        vec_ZZ_p ret;
        ret.SetLength(num_inputs);
        for(int i = 0; i < num_inputs; i++)
        {
            if(DEBUG_INTERPOLATE)
                { 
                if(eval(polyRes, Alpha[i])  != 2*(RSMaxLength*offset + i))
                {
                    cout << "ERROR: " << eval(polyRes, Alpha[i]) << endl;
                    exit(0);
                }
            }
            ret[i] = eval(polyRes, Alpha[i]);
        }
        return ret;
    }

    vec_ZZ_p compute_ole(vec_ZZ_p x, int inputLength, vec_ZZ_p Alpha, vec_ZZ_p Beta)
    {
     
        /* Setup the communication channels*/

        
        NetIO* ios[2];
        for(int i = 0; i < 2; ++i) {ios[i] = new NetIO(party == ALICE?nullptr:"127.0.0.1",port+i);} 



        /*
        We will first split the inputs into smaller chunks for the RS encoding
        For a large number of OLEs, we will need to set the security parameter high which is going to be infeasible
        x is the input and X is the array of smaller input sizes
        */
        vec_ZZ_p X[num_encoding_instances];
        for(int i = 0, k = 0; i < num_encoding_instances; i++)
        {
            X[i].SetLength(RSMaxLength);
            for(int j = 0; j < RSMaxLength; j++)
            {
                if(k >= inputLength)
                    X[i][j] = 1;
                else
                    X[i][j] = x[k++];
            }
        }
        

        /* 
        We will generate encodings for each of the smaller input sets
        V is the array of vectors returned from the encoding process
        This should be done in parallel (ideally) and as preprocessing
        */
        cout << "Setting up the server with " << num_encoding_instances << " instances ..." << endl;
        vec_ZZ_p V[num_encoding_instances];
        auto start_time = high_resolution_clock::now();    
        for(int i = 0; i < num_encoding_instances; i++)
        {
            V[i] = encode_rs(X[i], RSMaxLength, Alpha, Beta);
        }
        auto end_time = high_resolution_clock::now();
        auto duration = duration_cast<milliseconds>(end_time - start_time);
        // std::cout << "Server: Encoding time (offline): " << duration.count() << "ms" << endl;


        /*
        We will send all the encoding vectors generated above in one shot
        */

       start_time = high_resolution_clock::now();  
       block *b_v = new block[n*num_encoding_instances];
       
       for (int i = 0, k = 0; i < num_encoding_instances; i++)
       {     for(int j = 0; j < n; j++)
        {
        
            uint64_t high = uint64_t(conv<ulong>((conv<ZZ>(V[i][j])>>64)));
            uint64_t low = uint64_t(conv<ulong>((conv<ZZ>(V[i][j]))));
            b_v[k++] = makeBlock(high,low);
            if(DEBUG_COMM_V) cout << "S[V] : " << i << " " << j << " " << high << " " << low << " " << V[i][j] <<  endl;
        }
       }
        
        ios[0]->send_block(b_v, n*num_encoding_instances);
        end_time = high_resolution_clock::now();
        duration = duration_cast<milliseconds>(end_time - start_time);
        // std::cout << "Receiver: Sending OLE vector time: " << duration.count() << "ms" << endl; 
        cout << "Server OLE Cost: " << 2*(sizeof(block)*n*num_encoding_instances)*0.000125 << "KB" << endl;


        /*
        we will receive the blinded vectors from the client in one shot
        Then, we will break them down into the necessary chunks
        W is the array of vectors that will hold these chunks
        */

        block *b_w = new block[num_encoding_instances*n];
        ios[0]->recv_block(b_w,num_encoding_instances*n);
        vec_ZZ_p W[num_encoding_instances];
        for(int i = 0, k = 0; i < num_encoding_instances; i++)
        {
            W[i].SetLength(n);
            for(int j = 0; j < n; j++)
            {
                uint64_t *blk = (uint64_t*) &b_w[k];
                uint64_t high = uint64_t(blk[1]);
                uint64_t low = uint64_t(blk[0]);
                ZZ comb_zz = get_zz_from_uint(high,low); //ZZ(comb);

                W[i][j] = conv<ZZ_p>(comb_zz);
                if(DEBUG_COMM_W) cout << "R[W] : " << i << " " << j << " " << high << " " << low << " " <<  comb_zz << " " << W[i][j] <<  endl;
                k++;
            }
        }
        ios[0]->flush();

        /*
        We will set up the OT, 
        the chunks corresponding to all encoding instances will be shared in one shot 
        */

        IKNP<NetIO> ot(ios[1]);
        int ot_length = num_encoding_instances*n;

        bool *c = new bool[ot_length];
        block *recv = new block[ot_length];
        int k = 0;
        for(int i = 0; i < num_encoding_instances; i++)
        {    
            for(int j= 0; j < n; j++)
            {
                if(j < l)
                    c[k] = 0;
                else
                    c[k] = 1;
                k++;
            }
           
        }

        ot.recv(recv,c, ot_length);

        
        for(int i = 0, k = 0; i < num_encoding_instances; i++)
        {
            for(int j = 0; j < n; j++)
            {
                uint64_t *blk = (uint64_t*) &recv[k];
                if(j < l)
                {
                    ZZ comb = get_zz_from_uint(blk[1], blk[0]);
                    ZZ_p t = conv<ZZ_p>(comb);
                    W[i][j] = ZZ_p(W[i][j] - t);
                    if(DEBUG_OT) cout << blk[1] << " " << blk[0] << " " << W[i][j] << endl;
                    //cout << i << " " << w[i] << " " << w[i] - ZZ_p(blk[0]) << endl;
                }   
                k++; 
           }
        }   

        /*
        Finally we will get the OLE results
        We need to be careful that each encoding instance will be different
        If we are reusing the values of Alpha and Beta, this may not be a problem
        Whether this is correct from a security pov needs to be analyzed
        */
       
        vec_ZZ_p interpolating_sets[num_encoding_instances];   
        vec_ZZ_p ret;
        ret.SetLength(inputLength);

        start_time = high_resolution_clock::now();
        
        for(int i = 0,k = 0; i < num_encoding_instances; i++)
        {
            interpolating_sets[i].SetLength(l);
            for(int j = 0; j < l; j++)
            {
                interpolating_sets[i][j] = W[i][j];
            }
            vec_ZZ_p tmp;
            if(i < num_encoding_instances-1) tmp = ole_get_results(interpolating_sets[i], Beta, Alpha, i, RSMaxLength);
            else tmp = ole_get_results(interpolating_sets[num_encoding_instances-1], Beta, Alpha, num_encoding_instances-1, inputLength%RSMaxLength);
            for(int j = 0; j < tmp.length(); j++)   
            {
                ret[k++] = tmp[j];
            }    
        }
        
        end_time = high_resolution_clock::now();
        duration = duration_cast<milliseconds>(end_time - start_time);
        std::cout << "Server OLE time: " << duration.count() << "ms" << endl; 

        ios[0]->flush();
        ios[1]->flush();
        return ret;
        
        
        }

        
    };

    #endif