#include <emp-tool/emp-tool.h>
#include <emp-ot/ot.h>
#include "../include/constants.h"
#include "../include/Reed-Solomon.h"
#include "../include/Simhash.h"
#include "../include/AES.h"
#include "../include/Authentication.h"
#include "../include/OLESender.h"
#include "../include/OLEReceiver.h"
#include "../include/PSISender.h"
#include "../include/PSIReceiver.h"
#include <emp-sh2pc/emp-sh2pc.h>
#include "NTL/ZZ_pXFactoring.h"
#include "NTL/ZZ_p.h"
#include "NTL/vec_ZZ_p.h"
#include "NTL/ZZ.h"
#include<chrono>
#include "NTL/matrix.h"
#include "NTL/vec_vec_ZZ_p.h"
#include "NTL/BasicThreadPool.h"
#include<vector>
#include<numeric>
#include<algorithm>
#include <thread>
#include<future>
#include<iostream>
#include <cstdlib>
#include<string>
#include <fstream>
#if defined(__linux__)
        #include <sys/time.h>
        #include <sys/resource.h>
#elif defined(__APPLE__)
        #include <unistd.h>
        #include <sys/resource.h>
        #include <mach/mach.h>
#endif

using namespace std;
using namespace emp;
using namespace chrono;
using namespace NTL;


int party, port;
NetIO * netio;

#define TEST_Reg 0
#define TEST_Auth 1


vec_ZZ_p Simhash_gen(std::vector<std::string> file_block) {
  int num_encoding_instances = 10;

  ZZ_p::init(prime);
  ZZ_pContext context;
  context.save();

  vec_ZZ_p P; //= random_vec_ZZ_p(n+secParam);
  P.SetLength(n + secParam);
  for(int i = 0; i < n + secParam; i++)
  {
    P[i] = conv<ZZ_p>(ZZ(67*(2*i + 1)));
  }

  // Defining the set of alphas
  vec_ZZ_p Alpha;
  Alpha.SetLength(k);
  int i = 0;
  for(i; i < k; i++)
  {
    Alpha[i] = P[i];
  } 

  // Defining the set of betas
  vec_ZZ_p Beta;
  Beta.SetLength(n);
  int j = 0;
  for(i,j; j < n; i++, j++)
  {
    Beta[j] = P[i];
  }

  int num_fragments = file_block.size()*num_encoding_instances;
  vec_ZZ_p erasure_coded_fragments[num_fragments];
  for (size_t b = 0; b < file_block.size(); b++) {
    vector<int> ascii_array = strtoASCII(file_block[b]);

    vec_ZZ_p X[num_encoding_instances];
    for(int i = 0, k = 0; i < num_encoding_instances; i++)
    {
      X[i].SetLength(RSMaxLength);
      for(int j = 0; j < RSMaxLength; j++)
      {
        // if(k >= RSMaxLength)
        //   X[i][j] = 1;
        // else
          X[i][j] = ascii_array[k++];
      }
      erasure_coded_fragments[b*num_encoding_instances+i] = encode_rs(X[i], RSMaxLength, Alpha, Beta);
    }
  }

  vec_ZZ_p SIM_ret;

  for (int j=0; j<num_fragments; j++) {
      ZZ_p SIM_frag = Simhash(Simhash_helper(erasure_coded_fragments[j], num_fragments));
      SIM_ret.append(SIM_frag);
  }

  return SIM_ret;
}


void recommit(vec_ZZ_p eval_pts, vec_ZZ_p *inSet, int setSize)
{
 
    auto start_time = high_resolution_clock::now();
    
    block b_r[eval_pts.length()];
    vec_ZZ_p commit_elem;
    ZZ_p committed_elem;
    commit_elem.SetLength(eval_pts.length());
    std::string commit_elem_str;
    for(int i = 0; i < eval_pts.length(); i++)
    {
        ZZ_p sum_of_random_elements = ZZ_p(0);
        uint64_t *blk = (uint64_t*) &b_r[i];
        uint64_t high = uint64_t(blk[1]);
        uint64_t low = uint64_t(blk[0]);
        ZZ comb_zz = get_zz_from_uint(high,low); //ZZ(comb);
        commit_elem[i] = conv<ZZ_p>(comb_zz) + sum_of_random_elements;
        NTL::ZZ zzInteger;
        conv(zzInteger, commit_elem[i]);
        while (zzInteger != 0) {
            commit_elem_str += to_string((zzInteger % 10));
            zzInteger /= 10;
        }
            
        if(DEBUG_COMMIT) cout << "R[C1] : " << i << " " << high << " " << low << " " << comb_zz <<  endl;
    }

    reverse(commit_elem_str.begin(),commit_elem_str.end());
    const char* commit_elem_arr = commit_elem_str.c_str();
    committed_elem = sha256(commit_elem_arr);

    auto end_time = high_resolution_clock::now();
    auto duration = duration_cast<milliseconds>(end_time - start_time);
    std::cout << "Storage Server Rebuild Commitment Time: " << duration.count() << "ms" << endl; 

}



int main(int argc, char** argv) 
{

  /*
  - Registration
  Client offline time: 225ms
  Policy Checker offline time: 2010ms (10 file size list)

  Policy Checker: Encoding time (offline): 342ms
  
  Client: OLE time: 2ms
  Client: Total communication for sending blinded OLE vector: 307 KB
  Client OT Cost: 623 KB
  Client OT time: 606ms

  Policy Checker: Total communication for sending OLE vector: 307 KB
  Policy Checker OT Cost: 311 KB
  Policy Checker OT time: 20ms
  Policy Checker PSI time: 23ms
  Policy Checker Commit time: 78ms

  - Authentication
  Storage Server Offline Time: 69ms
  Policy Checker OT Cost: 2 KB
  Policy Checker Rebuild Commitment Time: 15ms
  Storage Server OT Cost: 2 KB
  Storage Server Rebuild Commitment Time: 17ms

  */

  if (TEST_Reg) {

  auto start_time = high_resolution_clock::now();

  //std::ifstream lfile("./emp-tool/circuits/sim_files/"+std::to_string(i)+".txt");
  std::ifstream lfile("../sim_files/1.txt");
  std::string line;
  std::string temp;
  std::vector<std::string> file_block;
  if(!lfile) // test the file open.
  {
    std::cout<<"Error opening output file"<< std::endl;
    system("pause");
    return -1;
  }

  while (std::getline(lfile, line))
  { 
    if (temp.length() + line.length() < 4000) {
      temp.append(line);
    }
    else {
      temp.append(line.substr(0,4000-temp.length()));
      file_block.push_back(temp);
      temp.clear();
    }
  } 

  vec_ZZ_p SIM_ret = Simhash_gen(file_block);

  int num_encoding_instances = 10;
  int num_fragments = file_block.size()*num_encoding_instances;
  
  auto end_time = high_resolution_clock::now();
  auto duration = duration_cast<milliseconds>(end_time - start_time);
  std::cout << "Client offline time: " << duration.count() << "ms" << endl; 


  start_time = high_resolution_clock::now();
  vector<vec_ZZ_p> SIM_list;

  for (size_t f=0; f<10; f++) {
    //std::ifstream lfile("../sim_files/"+std::to_string(f)+".txt");
    std::ifstream lfile("../sim_files/1.txt");
    std::string line;
    std::string temp;
    std::vector<std::string> file_block;
    if(!lfile) // test the file open.
    {
      std::cout<<"Error opening output file"<< std::endl;
      system("pause");
      return -1;
    }

    while (std::getline(lfile, line))
    { 
      if (temp.length() + line.length() < 4000) {
        temp.append(line);
      }
      else {
        temp.append(line.substr(0,4000-temp.length()));
        file_block.push_back(temp);
        temp.clear();
      }
    } 

    vec_ZZ_p SIM_item = Simhash_gen(file_block);
    
    SIM_list.push_back(SIM_item);
  }
  
  end_time = high_resolution_clock::now();
  duration = duration_cast<milliseconds>(end_time - start_time);
  std::cout << "Policy Checker offline time: " << duration.count() << "ms" << endl; 

  ZZ_p::init(prime);
    //ZZ_p::init(ZZ(pow(2,57) - 1));
    ZZ_pContext context;
    context.save();

    vec_ZZ_p P; //= random_vec_ZZ_p(n+secParam);
    P.SetLength(n + secParam);
    for(int i = 0; i < n + secParam; i++)
    {
        P[i] = conv<ZZ_p>(ZZ(67*(2*i + 1)));
    }


    int setSize = SIM_list.size();
    int ESPVecLen = num_fragments;

    vec_ZZ_p eval_points;
    eval_points.SetLength(2*ESPVecLen+1);
    for(int i = 0; i < eval_points.length(); i++)
    {
        eval_points[i] = conv<ZZ_p>(ZZ(57*(2*i + 1)));
    }

    // Defining the set of alphas
    vec_ZZ_p Alpha;
    Alpha.SetLength(k);
    int i = 0;
    for(i; i < k; i++)
    {
        Alpha[i] = P[i];
    } 

    // Defining the set of betas
    vec_ZZ_p Beta;
    Beta.SetLength(n);
    int j = 0;
    for(i,j; j < n; i++, j++)
    {
        Beta[j] = P[i];
    } 
    

    /*\\
    vec_ZZ_p x;
    x.SetLength(inputLength);
    for(int i = 0; i < inputLength; i++)
    {
        x[i] = 1; //random_ZZ_p();
    }
    */


    vec_ZZ_p servers_input;
    vec_ZZ_p clients_input_mul;
    vec_ZZ_p clients_input_add;
    int inputLength = 4*setSize*ESPVecLen;       // Number of OLEs we will require
    servers_input.SetLength(inputLength);
    clients_input_mul.SetLength(inputLength);
    clients_input_add.SetLength(inputLength);


    /* These values are only for testing */
    for(int i = 0; i < inputLength; i++)
    {
        servers_input[i] = 1; //random_ZZ_p();            
        clients_input_mul[i] = i;
        clients_input_add[i] = i;
    }



    parse_party_and_port(argv, &party, &port);
    //NetIO* ios[2];
    //for(int i = 0; i < 2; ++i) {ios[i] = new NetIO(party == ALICE?nullptr:"127.0.0.1",port+i);}         // We need two channels, one for communicating in the plain, the other for the OT
    
    int num_of_oles = inputLength;          // a number that is a multiple of 50
    int num_of_ole_instances;
    if(num_of_oles <= RSMaxLength)
        num_of_ole_instances = 1;
    else
        num_of_ole_instances = num_of_oles/RSMaxLength + 1;


    /* for testing embed and map*/

    ZZ_pX embed_map_key_poly_one; //= random_ZZ_pX(ESPVecLen);
    ZZ_pX embed_map_key_poly_two;  //= random_ZZ_pX(2*ESPVecLen);
    vec_ZZ_p embed_map_key_poly_one_pts; 
    embed_map_key_poly_one_pts.SetLength(ESPVecLen + 1);
    vec_ZZ_p embed_map_key_poly_two_pts;
    embed_map_key_poly_two_pts.SetLength(2*ESPVecLen + 1);
    vec_ZZ_p set_of_X_for_key_poly_one;
    set_of_X_for_key_poly_one.SetLength(ESPVecLen + 1);
    vec_ZZ_p set_of_X_for_key_poly_two;
    set_of_X_for_key_poly_two.SetLength(2*ESPVecLen + 1);


    for(int i = 0; i < ESPVecLen + 1; i++)
    {
        embed_map_key_poly_one_pts[i] = 103*i + 5;
        set_of_X_for_key_poly_one[i] = eval_points[i];
    }
    embed_map_key_poly_one = interpolate(set_of_X_for_key_poly_one, embed_map_key_poly_one_pts);


        for(int i = 0; i < 2*ESPVecLen + 1; i++)
    {
        embed_map_key_poly_two_pts[i] = 83*i + 3;
        set_of_X_for_key_poly_two[i] = eval_points[i];
    }
    embed_map_key_poly_two = interpolate(set_of_X_for_key_poly_two, embed_map_key_poly_two_pts);


    if(party == ALICE)      /* Receiver (Policy Checker)*/
    {
        vec_ZZ_p inSet[setSize];
        for(int i = 0; i < setSize; i++)
        {
            inSet[i].SetLength(ESPVecLen);
            for(int j = 0; j < ESPVecLen; j++)
            {
                inSet[i][j] = j+1; //random_ZZ_p();
            }
        }
      
        PSIReceiver psi_receiver = PSIReceiver(port, setSize, context, prime, ESPVecLen, Alpha, Beta);    
        //psi_receiver.get_intersection(eval_points, inSet);
        psi_receiver.test_and_commit(eval_points, inSet, embed_map_key_poly_one, embed_map_key_poly_two);

    }

    else                /* Sender (Cient) */
    {   
        vec_ZZ_p inSet[setSize];
        for(int i = 0; i < setSize; i++)
        {
            inSet[i].SetLength(ESPVecLen);
            for(int j = 0; j < ESPVecLen; j++)
            {
                inSet[i][j] = 2*j + 1; //random_ZZ_p();
            }
        }
        
        PSISender psi_sender = PSISender(port, setSize, context, prime, ESPVecLen, Alpha, Beta);    
        //psi_sender.get_intersection(eval_points, inSet);
        psi_sender.test_and_commit(eval_points, inSet, embed_map_key_poly_one, embed_map_key_poly_two);

    }

    }

    if (TEST_Auth) {

      std::ifstream lfile("../sim_files/1.txt");
      std::string line;
      std::string temp;
      std::vector<std::string> file_block;
      if(!lfile) // test the file open.
      {
        std::cout<<"Error opening output file"<< std::endl;
        system("pause");
        return -1;
      }

      while (std::getline(lfile, line))
      { 
        if (temp.length() + line.length() < 4000) {
          temp.append(line);
        }
        else {
          temp.append(line.substr(0,4000-temp.length()));
          file_block.push_back(temp);
          temp.clear();
          break;
        }
      } 

      
      int num_encoding_instances = 10;
      int num_fragments = file_block.size()*num_encoding_instances;

      auto start_time = high_resolution_clock::now();

      vec_ZZ_p SIM_ret = Simhash_gen(file_block);

      auto end_time = high_resolution_clock::now();
      auto duration = duration_cast<milliseconds>(end_time - start_time);
      std::cout << "Storage Server Offline Time: " << duration.count() << "ms" << endl; 

      start_time = high_resolution_clock::now();

    vec_ZZ_p r = random_vec_ZZ_p(64);

    vec_ZZ_p ss, y_S_vec;
    for (int i=0; i<SIM_ret.length(); i++) {
      ss.append(secret_share(SIM_ret[i], 64));
    }

    for (int i=0; i<SIM_ret.length(); i++) {
      y_S_vec.append(secret_share(SIM_ret[i], 64));
    }
    vec_ZZ_p sub;
    for (int i=0; i<64; i++) {
      sub.append(ss[i]-r[i]*y_S_vec[i]);
    }

    end_time = high_resolution_clock::now();
    duration = duration_cast<milliseconds>(end_time - start_time);
    std::cout << "Server Authentication Offline time: " << duration.count() << "ms" << endl;

      ZZ_p::init(prime);
    //ZZ_p::init(ZZ(pow(2,57) - 1));
    ZZ_pContext context;
    context.save();

    vec_ZZ_p P; //= random_vec_ZZ_p(n+secParam);
    P.SetLength(n + secParam);
    for(int i = 0; i < n + secParam; i++)
    {
        P[i] = conv<ZZ_p>(ZZ(67*(2*i + 1)));
    }


    int setSize = num_fragments;
    int ESPVecLen = num_fragments;

    vec_ZZ_p eval_points;
    eval_points.SetLength(2*ESPVecLen+1);
    for(int i = 0; i < eval_points.length(); i++)
    {
        eval_points[i] = conv<ZZ_p>(ZZ(57*(2*i + 1)));
    }

    // Defining the set of alphas
    vec_ZZ_p Alpha;
    Alpha.SetLength(k);
    int i = 0;
    for(i; i < k; i++)
    {
        Alpha[i] = P[i];
    } 

    // Defining the set of betas
    vec_ZZ_p Beta;
    Beta.SetLength(n);
    int j = 0;
    for(i,j; j < n; i++, j++)
    {
        Beta[j] = P[i];
    } 
    

    /*\\
    vec_ZZ_p x;
    x.SetLength(inputLength);
    for(int i = 0; i < inputLength; i++)
    {
        x[i] = 1; //random_ZZ_p();
    }
    */


    vec_ZZ_p servers_input;
    vec_ZZ_p clients_input_mul;
    vec_ZZ_p clients_input_add;
    int inputLength = 4*setSize*ESPVecLen;       // Number of OLEs we will require
    servers_input.SetLength(inputLength);
    clients_input_mul.SetLength(inputLength);
    clients_input_add.SetLength(inputLength);


    /* These values are only for testing */
    for(int i = 0; i < inputLength; i++)
    {
        servers_input[i] = 1; //random_ZZ_p();            
        clients_input_mul[i] = i;
        clients_input_add[i] = i;
    }




    parse_party_and_port(argv, &party, &port);
    //NetIO* ios[2];
    //for(int i = 0; i < 2; ++i) {ios[i] = new NetIO(party == ALICE?nullptr:"127.0.0.1",port+i);}         // We need two channels, one for communicating in the plain, the other for the OT
    
    int num_of_oles = inputLength;          // a number that is a multiple of 50
    int num_of_ole_instances;
    if(num_of_oles <= RSMaxLength)
        num_of_ole_instances = 1;
    else
        num_of_ole_instances = num_of_oles/RSMaxLength + 1;


    /* for testing embed and map*/

    ZZ_pX embed_map_key_poly_one; //= random_ZZ_pX(ESPVecLen);
    ZZ_pX embed_map_key_poly_two;  //= random_ZZ_pX(2*ESPVecLen);
    vec_ZZ_p embed_map_key_poly_one_pts; 
    embed_map_key_poly_one_pts.SetLength(ESPVecLen + 1);
    vec_ZZ_p embed_map_key_poly_two_pts;
    embed_map_key_poly_two_pts.SetLength(2*ESPVecLen + 1);
    vec_ZZ_p set_of_X_for_key_poly_one;
    set_of_X_for_key_poly_one.SetLength(ESPVecLen + 1);
    vec_ZZ_p set_of_X_for_key_poly_two;
    set_of_X_for_key_poly_two.SetLength(2*ESPVecLen + 1);


    for(int i = 0; i < ESPVecLen + 1; i++)
    {
        embed_map_key_poly_one_pts[i] = 103*i + 5;
        set_of_X_for_key_poly_one[i] = eval_points[i];
    }
    embed_map_key_poly_one = interpolate(set_of_X_for_key_poly_one, embed_map_key_poly_one_pts);


        for(int i = 0; i < 2*ESPVecLen + 1; i++)
    {
        embed_map_key_poly_two_pts[i] = 83*i + 3;
        set_of_X_for_key_poly_two[i] = eval_points[i];
    }
    embed_map_key_poly_two = interpolate(set_of_X_for_key_poly_two, embed_map_key_poly_two_pts);


    if(party == ALICE)      /* Receiver (Policy Checker)*/
    {
        vec_ZZ_p inSet[setSize];
        for(int i = 0; i < setSize; i++)
        {
            inSet[i].SetLength(ESPVecLen);
            for(int j = 0; j < ESPVecLen; j++)
            {
                inSet[i][j] = j+1; //random_ZZ_p();
            }
        }
      
        PSIReceiver psi_receiver = PSIReceiver(port, setSize, context, prime, ESPVecLen, Alpha, Beta);    
        //psi_receiver.get_intersection(eval_points, inSet);
        psi_receiver.authenticate(eval_points, inSet, embed_map_key_poly_one);

    }

    else                /* Sender (Storage Server) */
    {   
        vec_ZZ_p inSet[setSize];
        for(int i = 0; i < setSize; i++)
        {
            inSet[i].SetLength(ESPVecLen);
            for(int j = 0; j < ESPVecLen; j++)
            {
                inSet[i][j] = 2*j + 1; //random_ZZ_p();
            }
        }
        
        PSISender psi_sender = PSISender(port, setSize, context, prime, ESPVecLen, Alpha, Beta);    
        //psi_sender.get_intersection(eval_points, inSet);
        psi_sender.authenticate(eval_points, inSet, embed_map_key_poly_one);

    }

    }

	return 0;

}